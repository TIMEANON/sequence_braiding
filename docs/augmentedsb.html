<!DOCTYPE html>
<html lang="en">
<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  <title>Sequence Braiding</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="images/favicon.png">

  <!-- Libs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <script src="https://d3js.org/d3.v4.min.js"></script>

</head>
<body>

  <svg id='chess-svg' style='margin-left: 5%'></svg>

</body>
<script src='../lib/align_pair_quad.js'></script>
<script src='../lib/pairwise_alignment_dna.js'></script>
<script src='../js/util.js'></script>
<script src='../js/SequenceBraiding.js'></script>
<script type="text/javascript">
  graph1_options = {
    numDays: 10,
    minEventPerColThreshold: 1,
    height: 2000,
    width: window.innerWidth*0.7,
    forceLevelName: true,
    node_width_factor: 0.08,
    svg_width: window.innerWidth*0.95,
    //path: ['source', '1', '3', '5', '7', '9', '11', '13', '15', '17', 'sink']
    levels: ['very_high', 'high', 'normal', 'low', 'very_low']
  }

  d3.json('../data/jsonglucose.json', (error, data) => {

    //data.splice(0, 0)
    data = data.filter(d => d.length > 1)

    graph_sandbox = new SequenceBraiding(data, 'chess-svg', graph1_options)

    svg = graph_sandbox.svg
    details = ['date', 'glucose_graph']
    row_height = 20

    d3.json('../data/seq_info.json', (error, data) => {
      data = data.filter(d => graph_sandbox.data.map(a => a[0].seq_index).indexOf(d.seq_index) != -1)
      data = data.sort((a, b) => {
        node_col_a = graph_sandbox.nodes.filter(n => n.seq_index == a.seq_index && !n.fake_out)
        last_node_a = node_col_a[node_col_a.length - 1]
        node_col_b = graph_sandbox.nodes.filter(n => n.seq_index == b.seq_index && !n.fake_out)
        last_node_b = node_col_b[node_col_b.length - 1]

        if (last_node_a.y == last_node_b.y) return last_node_a.depth > last_node_b.depth

        return last_node_a.y > last_node_b.y
      })
      for (i in data){
        g = svg.append('g')
        .attr('transform', 'translate(' + (graph1_options.width + 30) + ',' + (i * row_height + graph_sandbox.top_padding) +')')

        // connector
        g.append('circle')
          .attr('cx', 0)
          .attr('cy', -4)
          .attr('r', row_height/6)
          .attr('fill', 'gray')

        node_col = graph_sandbox.nodes.filter(n => n.seq_index == data[i].seq_index && !n.fake_out)
        last_node = node_col[node_col.length - 1]

        var line = d3.line()
          .x(function(d, i) { return d.x })
          .y(function(d) { return d.y })
          .curve(d3.curveCatmullRom.alpha(1))

        pathpad = (graph_sandbox.path.length - last_node.depth - 2) * graph_sandbox.horizontal_spacing + graph_sandbox.left_padding + graph_sandbox.node_width

        svg.append('path')
          .attr('stroke', 'gray')
          .attr('fill', 'none')
          .attr('opacity', 0.5)
          .attr('d', line([
            {x: graph1_options.width - 40 - pathpad, y: last_node.y * graph_sandbox.vertical_spacing + graph_sandbox.top_padding},
            {x: graph1_options.width - 38 - pathpad, y: last_node.y * graph_sandbox.vertical_spacing + graph_sandbox.top_padding},
            {x: graph1_options.width + 28, y: i * row_height + graph_sandbox.top_padding - 4},
            {x: graph1_options.width + 30, y: i * row_height + graph_sandbox.top_padding - 4}]))

        // date
        pad = function (num) { return ("0"+num).slice(-2);}
        day = new Date(data[i].date)

        g.append('text')
          .attr('font-size', '0.7em')
          .attr('transform', 'translate('+ 10 +',0)')
          .text(day.getFullYear() + '.' + pad(day.getMonth()+1) + '.' + pad(day.getDate()))

        weekday = new Date(data[i].date).getDay()
        switch (weekday) {
          case 0: weekday = 'U'; break;
          case 1: weekday = 'M'; break;
          case 2: weekday = 'T'; break;
          case 3: weekday = 'W'; break;
          case 4: weekday = 'R'; break;
          case 5: weekday = 'F'; break;
          case 6: weekday = 'S'; break;
          default: weekday = 'Error'
        }

        g.append('text')
          .attr('font-size', '0.7em')
          .attr('transform', 'translate('+ 70 +',0)')
          .text(weekday)

        // carbs
        carbs_chart = g.append('g').attr('transform', 'translate('+ 85 +',0)')

        carbs_chart.selectAll('rect')
          .data(data[i].carbs)
          .enter()
          .append('rect')
          .attr('x', (d, i) => i*5)
          .attr('y', d => - d/10)
          .attr('width', 4)
          .attr('height', d => d/10)
          .attr('fill', '#029DAF')

        // time ratio
        time_ratio_chart = g.append('g').attr('transform', 'translate('+ 150 +',0)')
        width_factor = 60
        minipadding = 0.03
        height_factor = 0.7
        levels = graph_sandbox.opt.levels

        for (l in levels){
          llev = levels.slice(0, l)
          prevsum = 0
          for (ll of llev) prevsum += data[i]['time_ratio'][ll] + minipadding
          lw = Math.max(data[i]['time_ratio'][levels[l]], 0.009)

          time_ratio_chart.append('rect')
            .attr('width', lw*width_factor)
            .attr('height', row_height*height_factor)
            .attr('fill', graph_sandbox.opt.colorscheme[l])
            .attr('transform', 'translate('+((prevsum)*width_factor)+','+ -row_height/2 +')')
        }

        // time_ratio_chart.append('rect')
        //   .attr('width', data[i]['time_ratio']['very_high']*width_factor)
        //   .attr('height', row_height*height_factor)
        //   .attr('fill', graph_sandbox.opt.colorscheme[0])
        //   .attr('transform', 'translate('+0+','+ -row_height/2 +')')
        //
        //
        //
        // time_ratio_chart.append('rect')
        //   .attr('width', data[i]['time_ratio']['normal']*width_factor)
        //   .attr('height', row_height*height_factor)
        //   .attr('fill', graph_sandbox.opt.colorscheme[2])
        //   .attr('transform', 'translate('+(data[i]['time_ratio']['high'] + data[i]['time_ratio']['very_high'] + minipadding*2)*width_factor+','+ -row_height/2 +')')
      }
    })

    // for (detail of details){
    //   svg.append('text')
    //     .attr('x', window.innerWidth*0.6)
    //     .attr('y', 100)
    //     .attr('font-size', 'small')
    //     .attr('transform', 'rotate(10)')
    //     .text(detail)
    // }
})
</script>
</html>
